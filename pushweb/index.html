<html>   
    <head>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.2/jquery-ui.min.js"></script>
        <script src="http://127.0.0.1:2974/static/hookbox.js"></script>
        <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.2/themes/ui-lightness/jquery-ui.css" type="text/css" />

            <script type="text/javascript">

function on_message_pushed( datagram ) {
     console.log("Got message published");
     console.log( datagram );
     new_colors = datagram;
     current_cube_colors = new_colors;
     update_view();  // calls into the renderer code
}


 function update_view() {
   // looks at the view sliders and renders-the cube with that and the current color-state
   var altitude = $("#slide_alt").val() / 100.0;
   var azimuth = $("#slide_azi").val() / 100.0;
   render_view(300, 300, altitude, azimuth, 15 );
   //window.setTimeout( update_view, 50 );
 }
 $(document).ready( function() {
   // Draw the cube in its default state when the page first loads
   update_view();
 });

// ####################################################################
// #################### Communications, Control #######################
// ####################################################################

    // create a connection object and setup the basic event callbacks.
    // finally, subcribe to "chan1".
    var conn = hookbox.connect('http://127.0.0.1:2974');
    //conn.onOpen = function() { alert("connection established!"); };
    conn.onError = function(err) { alert("Failed to connect to hookbox server: " + err.msg); };

    var subscription = null;
    conn.onSubscribed = function(channelName, _subscription) {
        subscription = _subscription;                
        subscription.onPublish = function(frame) {
            on_message_pushed( frame.payload )
        };  
    };

$(document).ready(function() {
   // Subscribe to the pubsub channel with the colors
   conn.subscribe("iframe");
});


// ####################################################################
// ###################### Cube-rendering ##############################
// ####################################################################

//-----------------------------------------------------------------------------             
// Standard 4D vector math utility methods
// When using 4D vectors, positions are represented by [ x, y, z, 1 ]
// and directions are represented by [ x, y, z, 0 ]
//-----------------------------------------------------------------------------             
function vec4() 
{
    this.v = [ 0, 0, 0, 1 ]
}

function vectorSubtract( a, b )
{
    var r = new vec4;
    r.v[0] = a.v[0] - b.v[0];
    r.v[1] = a.v[1] - b.v[1];
    r.v[2] = a.v[2] - b.v[2];
    r.v[3] = a.v[3] - b.v[3];  
    return r;          
}

function vectorSet( v, x, y, z, w )
{
    v.v[0] = x;
    v.v[1] = y;
    v.v[2] = z;
    v.v[3] = w;
}

function vectorCopy( v )
{
    var r = new vec4;
    r.v[0] = v.v[0];
    r.v[1] = v.v[1];
    r.v[2] = v.v[2];
    r.v[3] = v.v[3];
    return r;
}

function vectorNormalize( v )
{
    var mag = v.v[0] * v.v[0] + v.v[1] * v.v[1] + v.v[2] * v.v[2] + v.v[3] * v.v[3];
    if ( mag == 0.0 )
    {
        mag = 1.0
    }
    var r = new vec4;
    mag = Math.sqrt( 1.0 / mag );
    r.v[0] = v.v[0] * mag;
    r.v[1] = v.v[1] * mag;
    r.v[2] = v.v[2] * mag;
    r.v[3] = v.v[3] * mag;
    return r;
}

function vectorCross( a, b )
{
    var r = new vec4;
    r.v[0] = a.v[1]*b.v[2] - a.v[2]*b.v[1];
    r.v[1] = a.v[2]*b.v[0] - a.v[0]*b.v[2];
    r.v[2] = a.v[0]*b.v[1] - a.v[1]*b.v[0];
    r.v[3] = 0.0
    return r;
}


//-----------------------------------------------------------------------------             
// Note that we're doing column-major matrices. 
// Vectors are pre-multiplied by matrices to transform them, i.e. vtransform = mat * v;
// This is *not* the method OpenGL uses (they post-multiply vectors by matrices)
// If you're not familiar w/ matrices, the upper 3x3 represents a rotation
// and the 3rd column represents the translational component for a 
// orthonormal matrix.
//-----------------------------------------------------------------------------             
function matrix() 
{
    this.m = [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ];
}

function multiplyMatrix( a, b ) 
{
    var r = new matrix()
    r.m[0][0] = a.m[0][0] * b.m[0][0] + a.m[0][1] * b.m[1][0] + a.m[0][2] * b.m[2][0] + a.m[0][3] * b.m[3][0];
    r.m[0][1] = a.m[0][0] * b.m[0][1] + a.m[0][1] * b.m[1][1] + a.m[0][2] * b.m[2][1] + a.m[0][3] * b.m[3][1];
    r.m[0][2] = a.m[0][0] * b.m[0][2] + a.m[0][1] * b.m[1][2] + a.m[0][2] * b.m[2][2] + a.m[0][3] * b.m[3][2];
    r.m[0][3] = a.m[0][0] * b.m[0][3] + a.m[0][1] * b.m[1][3] + a.m[0][2] * b.m[2][3] + a.m[0][3] * b.m[3][3];

    r.m[1][0] = a.m[1][0] * b.m[0][0] + a.m[1][1] * b.m[1][0] + a.m[1][2] * b.m[2][0] + a.m[1][3] * b.m[3][0];
    r.m[1][1] = a.m[1][0] * b.m[0][1] + a.m[1][1] * b.m[1][1] + a.m[1][2] * b.m[2][1] + a.m[1][3] * b.m[3][1];
    r.m[1][2] = a.m[1][0] * b.m[0][2] + a.m[1][1] * b.m[1][2] + a.m[1][2] * b.m[2][2] + a.m[1][3] * b.m[3][2];
    r.m[1][3] = a.m[1][0] * b.m[0][3] + a.m[1][1] * b.m[1][3] + a.m[1][2] * b.m[2][3] + a.m[1][3] * b.m[3][3];

    r.m[2][0] = a.m[2][0] * b.m[0][0] + a.m[2][1] * b.m[1][0] + a.m[2][2] * b.m[2][0] + a.m[2][3] * b.m[3][0];
    r.m[2][1] = a.m[2][0] * b.m[0][1] + a.m[2][1] * b.m[1][1] + a.m[2][2] * b.m[2][1] + a.m[2][3] * b.m[3][1];
    r.m[2][2] = a.m[2][0] * b.m[0][2] + a.m[2][1] * b.m[1][2] + a.m[2][2] * b.m[2][2] + a.m[2][3] * b.m[3][2];
    r.m[2][3] = a.m[2][0] * b.m[0][3] + a.m[2][1] * b.m[1][3] + a.m[2][2] * b.m[2][3] + a.m[2][3] * b.m[3][3];

    r.m[3][0] = a.m[3][0] * b.m[0][0] + a.m[3][1] * b.m[1][0] + a.m[3][2] * b.m[2][0] + a.m[3][3] * b.m[3][0];
    r.m[3][1] = a.m[3][0] * b.m[0][1] + a.m[3][1] * b.m[1][1] + a.m[3][2] * b.m[2][1] + a.m[3][3] * b.m[3][1];
    r.m[3][2] = a.m[3][0] * b.m[0][2] + a.m[3][1] * b.m[1][2] + a.m[3][2] * b.m[2][2] + a.m[3][3] * b.m[3][2];
    r.m[3][3] = a.m[3][0] * b.m[0][3] + a.m[3][1] * b.m[1][3] + a.m[3][2] * b.m[2][3] + a.m[3][3] * b.m[3][3];
    return r;
}
                  
function vectorMultiply( m, v )
{
    var res = new vec4( );
    res.v[0] = m.m[0][0] * v.v[0] + m.m[0][1] * v.v[1] + m.m[0][2] * v.v[2] + m.m[0][3] * v.v[3];
    res.v[1] = m.m[1][0] * v.v[0] + m.m[1][1] * v.v[1] + m.m[1][2] * v.v[2] + m.m[1][3] * v.v[3];
    res.v[2] = m.m[2][0] * v.v[0] + m.m[2][1] * v.v[1] + m.m[2][2] * v.v[2] + m.m[2][3] * v.v[3];
    res.v[3] = m.m[3][0] * v.v[0] + m.m[3][1] * v.v[1] + m.m[3][2] * v.v[2] + m.m[3][3] * v.v[3];
    return res;
}

function vectorMultiplyProjective( m, v )
{
    // When doing a projective transformation, you end up with a w that is not 1
    // To turn it into a normal position vector, you must divide by w
    // which actually has the effect of doing the projection onto a plane where w = 1
    var r = new vec4( );
    r.v[0] = m.m[0][0] * v.v[0] + m.m[0][1] * v.v[1] + m.m[0][2] * v.v[2] + m.m[0][3] * v.v[3];
    r.v[1] = m.m[1][0] * v.v[0] + m.m[1][1] * v.v[1] + m.m[1][2] * v.v[2] + m.m[1][3] * v.v[3];
    r.v[2] = m.m[2][0] * v.v[0] + m.m[2][1] * v.v[1] + m.m[2][2] * v.v[2] + m.m[2][3] * v.v[3];
    r.v[3] = m.m[3][0] * v.v[0] + m.m[3][1] * v.v[1] + m.m[3][2] * v.v[2] + m.m[3][3] * v.v[3];     
    if ( r.v[3] != 0.0 ) 
    {
        oow = 1.0 / r.v[3];
        r.v[0] = r.v[0] * oow
        r.v[1] = r.v[1] * oow
        r.v[2] = r.v[2] * oow
    }
    r.v[3] = 1.0
    return r;
}


function matrixInvert( src )
{
    // NOTE: This only works for orthonormal matrices
    var r = new matrix()

    // Transpose the upper 3x3.
    r.m[0][0] = src.m[0][0];  r.m[0][1] = src.m[1][0]; r.m[0][2] = src.m[2][0];
    r.m[1][0] = src.m[0][1];  r.m[1][1] = src.m[1][1]; r.m[1][2] = src.m[2][1];
    r.m[2][0] = src.m[0][2];  r.m[2][1] = src.m[1][2]; r.m[2][2] = src.m[2][2];

    // Transform the translation.
    var vTrans = new vec4();
    vectorSet( vTrans, -src.m[0][3], -src.m[1][3], -src.m[2][3], 1.0 );
    var vNewTrans = vectorMultiply( r, vTrans );
    r.m[0][3] = vNewTrans.v[0];
    r.m[1][3] = vNewTrans.v[1];
    r.m[2][3] = vNewTrans.v[2]; 
    return r;
}


// This library requires vectormath.js.  
// Make sure you include it too
            
//-----------------------------------------------------------------------------             
// Some basics of doing a 3d -> 2d transformation: There are 3 important matrices
// 1) The 'camera' or 'view' matrix: This represents the *inverse* of position
// and orientation of the camera in world space, and is used to transform
// world-space points into the coordinate frame of the camera.
// The camera "looks" down its -z axis, its x axis is pointing right in the image plane
// and its y axis is pointing up in the image plane. All geometry will be projected
// onto the z = -1 plane.
// 2) The 'projection' matrix: This transforms geometry in camera space to
// lie on the z =-1 plane. In projection space, everything that lies
// between -1 and 1 in x, y and z will show up on screen.
// 3) The 'viewport' matrix: This transforms geometry in projection space to
// pixel space on screen by translating and scaling x and y. Z is left unchanged.
//-----------------------------------------------------------------------------             
function buildProjectionMatrix( left, right, bottom, top, near, far )
{
    var r = new matrix();
    r.m[0][0] = ( 2 * near ) / ( right - left );
    r.m[1][1] = ( 2 * near ) / ( top - bottom );
    r.m[2][0] = ( right + left ) / ( right - left );    
    r.m[2][1] = ( top + bottom ) / ( top - bottom );     
    
    r.m[2][3] = -1;
    r.m[3][2] = 2 * far * near / ( far - near );
    return r;
}

//-----------------------------------------------------------------------------             
// The way to think about how to build a view matrix: Start with trying to
// make a transform that transforms from camera space to world space.
// Such a transform should have the property that post-multiplying the
// matrix by the column vector [ 0 0 0 1 ] should result in the camera origin
// in world space. Post-multiplying the matrix by [ 0 0 1 0 ] should result
// in the 'z' axis of the camera in world space, etc. The first property means that
// the 3rd column (the translational component of the matrix) needs to be
// the camera location in 3D space (equals 'eye'). The second means that each
// column of the matrix represents the x, y, and z axes of the camera.
// Inverting this matrix results in the view matrix that transforms world-space
// points into camera-space points.
//-----------------------------------------------------------------------------             
function buildViewMatrix( eye, center, up )
{
    var f = vectorSubtract( eye, center );

    f = vectorNormalize( f );
    var s = vectorCross( up, f );
    s = vectorNormalize( s );
    var u = vectorCross( f, s );
    u = vectorNormalize( u );

    var t = new matrix();
    t.m[0][3] = eye.v[0];
    t.m[1][3] = eye.v[1];
    t.m[2][3] = eye.v[2];
  
    var rot = new matrix();
    rot.m[0][0] = s.v[0]; 
    rot.m[0][1] = u.v[0];
    rot.m[0][2] = f.v[0];
    
    rot.m[1][0] = s.v[1]; 
    rot.m[1][1] = u.v[1];
    rot.m[1][2] = f.v[1];
   
    rot.m[2][0] = s.v[2]; 
    rot.m[2][1] = u.v[2];
    rot.m[2][2] = f.v[2];

    var v = multiplyMatrix( t, rot );        
    var vInv = matrixInvert( v );    
    return vInv;
}

function buildViewportTransform( width, height )
{
    var r = new matrix();
    r.m[0][0] = 0.5 * width; 
    r.m[0][3] = 0.5 * height; 
    r.m[1][1] = -0.5 * height; 
    r.m[1][3] = 0.5 * height;
    return r; 
}
                    

//-----------------------------------------------------------------------------
// This draws a quad, projecting it from world space to screenspace, and then rendering it.
// Arguments:
// viewProj: a matrix which concatenates the view + projection matrices
// viewProjViewport: a matrix which concatenates the view, projection, and viewport matrices
// 
//-----------------------------------------------------------------------------             
function drawQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, color ) 
{
    // Backface cull first
    var b1 = vectorMultiplyProjective( viewProj, p1 );
    var b2 = vectorMultiplyProjective( viewProj, p2 );
    var b3 = vectorMultiplyProjective( viewProj, p3 );
    var e1 = vectorSubtract( b2, b1 );
    var e2 = vectorSubtract( b3, b1 );
    var c = vectorCross( e1, e2 );
    if ( c.v[2] <= 0.0 )
    {
        return;
    }
            
    ctx.fillStyle = "rgba(" + Math.round(255.0*color[2]) + "," + Math.round(255.0*color[1]) + "," + Math.round(255.0*color[0]) + ",1)";
    ctx.globalAlpha = 1.0; 
     
    // Transform all points into viewport space
    var vp1 = vectorMultiplyProjective( viewProjViewport, p1 );  
    var vp2 = vectorMultiplyProjective( viewProjViewport, p2 );  
    var vp3 = vectorMultiplyProjective( viewProjViewport, p3 );  
    var vp4 = vectorMultiplyProjective( viewProjViewport, p4 );
        
    // Draw a filled quad  
    ctx.beginPath();   
    ctx.moveTo(vp1.v[0], vp1.v[1]);   
    ctx.lineTo(vp2.v[0], vp2.v[1]);   
    ctx.lineTo(vp3.v[0], vp3.v[1]);   
    ctx.lineTo(vp4.v[0], vp4.v[1]);   
    ctx.closePath();   
    ctx.fill();
}   


function drawCube( ctx, viewProj, viewProjViewport, colors )
{
    // This code generates the 54 quads representing the 54 pixels of the cube    
    var crossAxis = [ [1, 2], [0, 2], [0, 1] ];
    var invertAxis = [ [false, false], [true, false], [true, false], [false, false], [false, false], [true, false] ];
    var gapSize = 0.08;
    var p = new vec4;
    var d = [ 0.0, 0.0, 0.0 ];
    var g = [ 0.0, 0.0, 0.0 ];

    for ( var i = 0; i < 6; ++i )
    {
        var axis = i >> 1;
        p.v[axis] = 3.0;
        if ( i & 1 )
        {
            p.v[axis] *= -1.0;
        }
        d[axis] = 0.0;

        var a0 = crossAxis[ axis ][ 0 ];
        var a1 = crossAxis[ axis ][ 1 ];
        var s0 = 1.0;
        var s1 = 1.0;
        if ( invertAxis[ i ][ 0 ] )
        {
            s0 *= -1.0;
        }
        if ( invertAxis[ i ][ 1 ] )
        {
            s1 *= -1.0
        }
        d[a0] = ( 2.0 - 2.0 * gapSize ) * s0;
        d[a1] = ( 2.0 - 2.0 * gapSize ) * s1;
        g[a0] = gapSize * s0;
        g[a1] = gapSize * s1;
        p.v[a1] = -3.0 * s1 + g[a1];
        for ( var j = 0; j < 3; j++ )
        {
            p.v[a0] = -3.0 * s0 + g[a0]
            for ( var k = 0; k < 3; k++ )
            {           
                var p1 = vectorCopy( p );

                p.v[ a0 ] += d[ a0 ]
                var p2 = vectorCopy( p );

                p.v[ a1 ] += d[ a1 ];
                var p3 = vectorCopy( p );
                
                p.v[ a0 ] -= d[ a0 ];
                var p4 = vectorCopy( p );

                var ndx = i*9 + j*3 + k        
                drawQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, colors[ndx] );
                
                p.v[ a1 ] -= d[ a1 ];
                p.v[ a0 ] += d[ a0 ] + 2.0 * g[ a0 ];
            }                     
            p.v[ a1 ] += d[ a1 ] + 2.0 * g[ a1 ];
        }
    }           
}

    // Define cube colors (these should be passed in)
    var faceColors = [ [ 0.0, 1.0, 0.0 ], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0] ];
    var current_cube_colors = new Array( 54 );
    var index = 0;
    for ( var i = 0; i < 6; ++i )
    {
        for ( var j = 0; j < 9; ++j )
        {
            current_cube_colors[index] = faceColors[i];
            index++;            
        }
    }


function render_view( width, height, altitude, azimuth, distance ) 
{ 
    var canvas = document.getElementById("canvas");   
    var ctx = canvas.getContext("2d");   

    // Clear to black
    ctx.save();   
    ctx.fillStyle = "black";   
    ctx.fillRect( 0, 0, width, height );   
    ctx.restore();   
    
    
    // Build the projection matrix
    // Note that the camera looks down -z in view space and the viewplane is at z = -1
    var aspectRatio = height / width;    
    var proj = buildProjectionMatrix( -0.3, 0.3, -0.3 * aspectRatio, 0.3 * aspectRatio, 1.0, 50.0 );

    // Build the view matrix
    var eye = new vec4;
    var center = new vec4;
    var up = new vec4;
    center.v[0] = distance * Math.sin( azimuth ) * Math.sin( altitude )
    center.v[1] = distance * Math.cos( altitude )
    center.v[2] = distance * Math.cos( azimuth ) * Math.sin( altitude )     
    up.v[1] = 1.0;
    eye.v[3] = center.v[3] = up.v[3] = 0.0;   
    var view = buildViewMatrix( center, eye, up );    

    // Build the viewport transform
    var viewport = buildViewportTransform( width, height );
   
    // viewProjViewport matrix will transform all points from world space to screen space
    var viewProj = multiplyMatrix( proj, view );
    var viewProjViewport = multiplyMatrix( viewport, viewProj );    
    
    drawCube( ctx, viewProj, viewProjViewport, current_cube_colors );
}


            </script>   
        </head>
    <body>
       <canvas id="canvas" width="300" height="300"></canvas>   

       <script>
       </script>

       <div>
          Altitude: <input id="slide_alt" type="range" min="1" max="313" value="220" onchange="update_view();"><br/>
          Azimuth: <input id="slide_azi" type="range" min="0" max="628" value="233" onchange="update_view();"><br/>
       </div>
    </body> 
</html>  


