<html>   
    <head>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.2/jquery-ui.min.js"></script>

<script type="text/javascript"> 
    // This code loads the hookbox.js from the current host but changing the port to 2974.
    // server = 'http://127.0.0.1:2974'; // hard-code from localhost
    server = location.protocol + '//' + location.hostname + ':2974';
    // Dynamically inserts the code to load the script into the page.
    document.write('<scr'+'ipt src="' + server + '/static/hookbox.js"></scr'+'ipt>');
</script>

            <script type="text/javascript">

// ####################################################################
// ######################## Control Logic #############################
// ####################################################################

function on_message_pushed( datagram ) {
     //console.log("Got message published");
     //console.log( datagram );
     new_colors = datagram;
     current_cube_colors = new_colors;
     update_view();  // calls into the renderer code
}


 function update_view() {
   // looks at the view sliders and renders-the cube with that and the current color-state
   var altitude = $("#slide_alt").val() / 100.0;
   var azimuth = $("#slide_azi").val() / 100.0;
   render_view(300, 300, altitude, azimuth, 15 );
   //window.setTimeout( update_view, 50 );
 }

 $(document).ready( function() {
    // Draw the cube in its default state when the page first loads
    update_view();

    $("#canvas").click( function( eventObj ) {
       //var x = eventObj.pageX;
       //var y = eventObj.pageY;
       //console.log("local click at absolute ("+x+","+y+")");

       var top_left_canvas_corner = $("#canvas").elementlocation();
       var x = eventObj.pageX - top_left_canvas_corner.x;
       var y = eventObj.pageY - top_left_canvas_corner.y;

       //console.log("local click at relative ("+x+","+y+")");

       cube_got_clicked_on(x,y);
    });
});

var faceclick_subscription;

function cube_got_clicked_on(x,y) {
    facenum = whichFaceIsPointIn(x,y);
    if( facenum < 0 ) {
      // not on a cube face
      console.log("Local click not on cube face.");
      return;
    }
    console.log("Publishing local click on face "+facenum);
    //faceclick_subscription.publish( facenum );  // docs say this should work but it doesn't
    hookbox_conn.publish( 'faceclick', facenum );
}


// ####################################################################
// #################### Communications Setup ##########################
// ####################################################################

// create a connection object and setup the basic event callbacks.
// finally, subcribe to "chan1".
//var hookbox_conn = hookbox.connect('http://127.0.0.1:2974');
var hookbox_conn = hookbox.connect(server);
//hookbox_conn.onOpen = function() { alert("connection established!"); };
hookbox_conn.onError = function(err) { alert("Failed to connect to hookbox server: " + err.msg); };

var subscription = null;
hookbox_conn.onSubscribed = function(channelName, _subscription) {
    if( channelName == 'iframe' ) {
        subscription = _subscription;                
        subscription.onPublish = function(frame) {
            on_message_pushed( frame.payload )
        };  
    }
    if( channelName == 'faceclick' ) {
        faceclick_subscription = _subscription;                
        faceclick_subscription.onPublish = function(frame) {
            console.log('Heard about click on face ' + frame.payload);
        };  
    }
};

$(document).ready(function() {
   // Subscribe to the pubsub channel with the colors
   hookbox_conn.subscribe("iframe");
   hookbox_conn.subscribe("faceclick");
});




// ####################################################################
// ###################### jquery helpers ##############################
// ####################################################################


jQuery.fn.elementlocation = function() {
  var curleft = 0;
  var curtop = 0;
 
  var obj = this;
 
  do {
    curleft += obj.attr('offsetLeft');
    curtop += obj.attr('offsetTop');
 
    obj = obj.offsetParent();
  } while ( obj.attr('tagName') != 'BODY' );
 
 
  return ( {x:curleft, y:curtop} );
};


// ####################################################################
// ###################### Cube-rendering ##############################
// ####################################################################

//-----------------------------------------------------------------------------             
// Standard 4D vector math utility methods
// When using 4D vectors, positions are represented by [ x, y, z, 1 ]
// and directions are represented by [ x, y, z, 0 ]
//-----------------------------------------------------------------------------             
function vec4() 
{
    this.v = [ 0, 0, 0, 1 ]
}

function vectorSubtract( a, b )
{
    var r = new vec4;
    r.v[0] = a.v[0] - b.v[0];
    r.v[1] = a.v[1] - b.v[1];
    r.v[2] = a.v[2] - b.v[2];
    r.v[3] = a.v[3] - b.v[3];  
    return r;          
}

function vectorAdd( a, b )
{
    var r = new vec4;
    r.v[0] = a.v[0] + b.v[0];
    r.v[1] = a.v[1] + b.v[1];
    r.v[2] = a.v[2] + b.v[2];
    r.v[3] = a.v[3] + b.v[3];
    return r;
}

function vectorMultiplyScalar( a, t )
{
    var r = new vec4;
    r.v[0] = a.v[0] * t;
    r.v[1] = a.v[1] * t;
    r.v[2] = a.v[2] * t;
    r.v[3] = a.v[3] * t;
    return r;
}

// When t = 0, returns a. When t == 1, returns b.
function vectorLerp( a, b, t )
{
    var d = vectorSubtract( b, a );
    var d1 = vectorMultiplyScalar( d, t );
    return vectorAdd( a, d1 );
}

// returns a + b * t (t is scalar)
function vectorMultiplyAdd( a, b, t )
{
    var d = vectorMultiplyScalar( b, t );
    return vectorAdd( a, d );
}

// returns a + b * t1 + c * t2 (t1,t2 is scalar)
function vectorMultiplyAdd2( a, b, t1, c, t2 )
{
    var d1 = vectorMultiplyScalar( b, t1 );
    var d2 = vectorMultiplyScalar( c, t2 );
    var s = vectorAdd( d1, d2 );
    return vectorAdd( a, s );
}

function vectorSet( v, x, y, z, w )
{
    v.v[0] = x;
    v.v[1] = y;
    v.v[2] = z;
    v.v[3] = w;
}

function vectorCopy( v )
{
    var r = new vec4;
    r.v[0] = v.v[0];
    r.v[1] = v.v[1];
    r.v[2] = v.v[2];
    r.v[3] = v.v[3];
    return r;
}

function vectorNormalize( v )
{
    var mag = v.v[0] * v.v[0] + v.v[1] * v.v[1] + v.v[2] * v.v[2] + v.v[3] * v.v[3];
    if ( mag == 0.0 )
    {
        mag = 1.0
    }
    var r = new vec4;
    mag = Math.sqrt( 1.0 / mag );
    r.v[0] = v.v[0] * mag;
    r.v[1] = v.v[1] * mag;
    r.v[2] = v.v[2] * mag;
    r.v[3] = v.v[3] * mag;
    return r;
}

function vectorCross( a, b )
{
    var r = new vec4;
    r.v[0] = a.v[1]*b.v[2] - a.v[2]*b.v[1];
    r.v[1] = a.v[2]*b.v[0] - a.v[0]*b.v[2];
    r.v[2] = a.v[0]*b.v[1] - a.v[1]*b.v[0];
    r.v[3] = 0.0
    return r;
}


//-----------------------------------------------------------------------------             
// Note that we're doing column-major matrices. 
// Vectors are pre-multiplied by matrices to transform them, i.e. vtransform = mat * v;
// This is *not* the method OpenGL uses (they post-multiply vectors by matrices)
// If you're not familiar w/ matrices, the upper 3x3 represents a rotation
// and the 3rd column represents the translational component for a 
// orthonormal matrix.
//-----------------------------------------------------------------------------             
function matrix() 
{
    this.m = [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ];
}

function multiplyMatrix( a, b ) 
{
    var r = new matrix()
    r.m[0][0] = a.m[0][0] * b.m[0][0] + a.m[0][1] * b.m[1][0] + a.m[0][2] * b.m[2][0] + a.m[0][3] * b.m[3][0];
    r.m[0][1] = a.m[0][0] * b.m[0][1] + a.m[0][1] * b.m[1][1] + a.m[0][2] * b.m[2][1] + a.m[0][3] * b.m[3][1];
    r.m[0][2] = a.m[0][0] * b.m[0][2] + a.m[0][1] * b.m[1][2] + a.m[0][2] * b.m[2][2] + a.m[0][3] * b.m[3][2];
    r.m[0][3] = a.m[0][0] * b.m[0][3] + a.m[0][1] * b.m[1][3] + a.m[0][2] * b.m[2][3] + a.m[0][3] * b.m[3][3];

    r.m[1][0] = a.m[1][0] * b.m[0][0] + a.m[1][1] * b.m[1][0] + a.m[1][2] * b.m[2][0] + a.m[1][3] * b.m[3][0];
    r.m[1][1] = a.m[1][0] * b.m[0][1] + a.m[1][1] * b.m[1][1] + a.m[1][2] * b.m[2][1] + a.m[1][3] * b.m[3][1];
    r.m[1][2] = a.m[1][0] * b.m[0][2] + a.m[1][1] * b.m[1][2] + a.m[1][2] * b.m[2][2] + a.m[1][3] * b.m[3][2];
    r.m[1][3] = a.m[1][0] * b.m[0][3] + a.m[1][1] * b.m[1][3] + a.m[1][2] * b.m[2][3] + a.m[1][3] * b.m[3][3];

    r.m[2][0] = a.m[2][0] * b.m[0][0] + a.m[2][1] * b.m[1][0] + a.m[2][2] * b.m[2][0] + a.m[2][3] * b.m[3][0];
    r.m[2][1] = a.m[2][0] * b.m[0][1] + a.m[2][1] * b.m[1][1] + a.m[2][2] * b.m[2][1] + a.m[2][3] * b.m[3][1];
    r.m[2][2] = a.m[2][0] * b.m[0][2] + a.m[2][1] * b.m[1][2] + a.m[2][2] * b.m[2][2] + a.m[2][3] * b.m[3][2];
    r.m[2][3] = a.m[2][0] * b.m[0][3] + a.m[2][1] * b.m[1][3] + a.m[2][2] * b.m[2][3] + a.m[2][3] * b.m[3][3];

    r.m[3][0] = a.m[3][0] * b.m[0][0] + a.m[3][1] * b.m[1][0] + a.m[3][2] * b.m[2][0] + a.m[3][3] * b.m[3][0];
    r.m[3][1] = a.m[3][0] * b.m[0][1] + a.m[3][1] * b.m[1][1] + a.m[3][2] * b.m[2][1] + a.m[3][3] * b.m[3][1];
    r.m[3][2] = a.m[3][0] * b.m[0][2] + a.m[3][1] * b.m[1][2] + a.m[3][2] * b.m[2][2] + a.m[3][3] * b.m[3][2];
    r.m[3][3] = a.m[3][0] * b.m[0][3] + a.m[3][1] * b.m[1][3] + a.m[3][2] * b.m[2][3] + a.m[3][3] * b.m[3][3];
    return r;
}
                  
function vectorMultiply( m, v )
{
    var res = new vec4( );
    res.v[0] = m.m[0][0] * v.v[0] + m.m[0][1] * v.v[1] + m.m[0][2] * v.v[2] + m.m[0][3] * v.v[3];
    res.v[1] = m.m[1][0] * v.v[0] + m.m[1][1] * v.v[1] + m.m[1][2] * v.v[2] + m.m[1][3] * v.v[3];
    res.v[2] = m.m[2][0] * v.v[0] + m.m[2][1] * v.v[1] + m.m[2][2] * v.v[2] + m.m[2][3] * v.v[3];
    res.v[3] = m.m[3][0] * v.v[0] + m.m[3][1] * v.v[1] + m.m[3][2] * v.v[2] + m.m[3][3] * v.v[3];
    return res;
}

function vectorMultiplyProjective( m, v )
{
    // When doing a projective transformation, you end up with a w that is not 1
    // To turn it into a normal position vector, you must divide by w
    // which actually has the effect of doing the projection onto a plane where w = 1
    var r = new vec4( );
    r.v[0] = m.m[0][0] * v.v[0] + m.m[0][1] * v.v[1] + m.m[0][2] * v.v[2] + m.m[0][3] * v.v[3];
    r.v[1] = m.m[1][0] * v.v[0] + m.m[1][1] * v.v[1] + m.m[1][2] * v.v[2] + m.m[1][3] * v.v[3];
    r.v[2] = m.m[2][0] * v.v[0] + m.m[2][1] * v.v[1] + m.m[2][2] * v.v[2] + m.m[2][3] * v.v[3];
    r.v[3] = m.m[3][0] * v.v[0] + m.m[3][1] * v.v[1] + m.m[3][2] * v.v[2] + m.m[3][3] * v.v[3];     
    if ( r.v[3] != 0.0 ) 
    {
        oow = 1.0 / r.v[3];
        r.v[0] = r.v[0] * oow
        r.v[1] = r.v[1] * oow
        r.v[2] = r.v[2] * oow
    }
    r.v[3] = 1.0
    return r;
}


function matrixInvert( src )
{
    // NOTE: This only works for orthonormal matrices
    var r = new matrix()

    // Transpose the upper 3x3.
    r.m[0][0] = src.m[0][0];  r.m[0][1] = src.m[1][0]; r.m[0][2] = src.m[2][0];
    r.m[1][0] = src.m[0][1];  r.m[1][1] = src.m[1][1]; r.m[1][2] = src.m[2][1];
    r.m[2][0] = src.m[0][2];  r.m[2][1] = src.m[1][2]; r.m[2][2] = src.m[2][2];

    // Transform the translation.
    var vTrans = new vec4();
    vectorSet( vTrans, -src.m[0][3], -src.m[1][3], -src.m[2][3], 1.0 );
    var vNewTrans = vectorMultiply( r, vTrans );
    r.m[0][3] = vNewTrans.v[0];
    r.m[1][3] = vNewTrans.v[1];
    r.m[2][3] = vNewTrans.v[2]; 
    return r;
}


// This library requires vectormath.js.  
// Make sure you include it too
            
//-----------------------------------------------------------------------------             
// Some basics of doing a 3d -> 2d transformation: There are 3 important matrices
// 1) The 'camera' or 'view' matrix: This represents the *inverse* of position
// and orientation of the camera in world space, and is used to transform
// world-space points into the coordinate frame of the camera.
// The camera "looks" down its -z axis, its x axis is pointing right in the image plane
// and its y axis is pointing up in the image plane. All geometry will be projected
// onto the z = -1 plane.
// 2) The 'projection' matrix: This transforms geometry in camera space to
// lie on the z =-1 plane. In projection space, everything that lies
// between -1 and 1 in x, y and z will show up on screen.
// 3) The 'viewport' matrix: This transforms geometry in projection space to
// pixel space on screen by translating and scaling x and y. Z is left unchanged.
//-----------------------------------------------------------------------------             
function buildProjectionMatrix( left, right, bottom, top, near, far )
{
    var r = new matrix();
    r.m[0][0] = ( 2 * near ) / ( right - left );
    r.m[1][1] = ( 2 * near ) / ( top - bottom );
    r.m[2][0] = ( right + left ) / ( right - left );    
    r.m[2][1] = ( top + bottom ) / ( top - bottom );     
    
    r.m[2][3] = -1;
    r.m[3][2] = 2 * far * near / ( far - near );
    return r;
}

//-----------------------------------------------------------------------------             
// The way to think about how to build a view matrix: Start with trying to
// make a transform that transforms from camera space to world space.
// Such a transform should have the property that post-multiplying the
// matrix by the column vector [ 0 0 0 1 ] should result in the camera origin
// in world space. Post-multiplying the matrix by [ 0 0 1 0 ] should result
// in the 'z' axis of the camera in world space, etc. The first property means that
// the 3rd column (the translational component of the matrix) needs to be
// the camera location in 3D space (equals 'eye'). The second means that each
// column of the matrix represents the x, y, and z axes of the camera.
// Inverting this matrix results in the view matrix that transforms world-space
// points into camera-space points.
//-----------------------------------------------------------------------------             
function buildViewMatrix( eye, center, up )
{
    var f = vectorSubtract( eye, center );

    f = vectorNormalize( f );
    var s = vectorCross( up, f );
    s = vectorNormalize( s );
    var u = vectorCross( f, s );
    u = vectorNormalize( u );

    var t = new matrix();
    t.m[0][3] = eye.v[0];
    t.m[1][3] = eye.v[1];
    t.m[2][3] = eye.v[2];
  
    var rot = new matrix();
    rot.m[0][0] = s.v[0]; 
    rot.m[0][1] = u.v[0];
    rot.m[0][2] = f.v[0];
    
    rot.m[1][0] = s.v[1]; 
    rot.m[1][1] = u.v[1];
    rot.m[1][2] = f.v[1];
   
    rot.m[2][0] = s.v[2]; 
    rot.m[2][1] = u.v[2];
    rot.m[2][2] = f.v[2];

    var v = multiplyMatrix( t, rot );        
    var vInv = matrixInvert( v );    
    return vInv;
}

function buildViewportTransform( width, height )
{
    var r = new matrix();
    r.m[0][0] = 0.5 * width; 
    r.m[0][3] = 0.5 * height; 
    r.m[1][1] = -0.5 * height; 
    r.m[1][3] = 0.5 * height;
    return r; 
}
                    

//-----------------------------------------------------------------------------
// This draws a quad, projecting it from world space to screenspace, and then rendering it.
// Arguments:
// viewProj: a matrix which concatenates the view + projection matrices
// viewProjViewport: a matrix which concatenates the view, projection, and viewport matrices
// 
//-----------------------------------------------------------------------------             
function drawQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, color ) 
{
    // Backface cull first
    var b1 = vectorMultiplyProjective( viewProj, p1 );
    var b2 = vectorMultiplyProjective( viewProj, p2 );
    var b3 = vectorMultiplyProjective( viewProj, p3 );
    var e1 = vectorSubtract( b2, b1 );
    var e2 = vectorSubtract( b3, b1 );
    var c = vectorCross( e1, e2 );
    if ( c.v[2] <= 0.0 )
    {
        return;
    }
            
    ctx.fillStyle = "rgba(" + Math.round(255.0*color[2]) + "," + Math.round(255.0*color[1]) + "," + Math.round(255.0*color[0]) + ",1)";
    ctx.globalAlpha = 1.0; 
     
    // Transform all points into viewport space
    var vp1 = vectorMultiplyProjective( viewProjViewport, p1 );  
    var vp2 = vectorMultiplyProjective( viewProjViewport, p2 );  
    var vp3 = vectorMultiplyProjective( viewProjViewport, p3 );  
    var vp4 = vectorMultiplyProjective( viewProjViewport, p4 );
        
    // Draw a filled quad  
    ctx.beginPath();   
    ctx.moveTo(vp1.v[0], vp1.v[1]);   
    ctx.lineTo(vp2.v[0], vp2.v[1]);   
    ctx.lineTo(vp3.v[0], vp3.v[1]);   
    ctx.lineTo(vp4.v[0], vp4.v[1]);   
    ctx.closePath();   
    ctx.fill();
}   

//-----------------------------------------------------------------------------
// This returns true if the specified point in screen space is inside the
// quad specified in world space.
// Arguments:
// viewProj: a matrix which concatenates the view + projection matrices
// viewProjViewport: a matrix which concatenates the view, projection, and viewport matrices
//-----------------------------------------------------------------------------
function isPointInQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, point )
{
    // Backface cull first, ignore backfaced triangles
    var b1 = vectorMultiplyProjective( viewProj, p1 );
    var b2 = vectorMultiplyProjective( viewProj, p2 );
    var b3 = vectorMultiplyProjective( viewProj, p3 );
    var e1 = vectorSubtract( b2, b1 );
    var e2 = vectorSubtract( b3, b1 );
    var c = vectorCross( e1, e2 );
    if ( c.v[2] <= 0.0 )
    {
        return;
    }

    // Transform all points into viewport space
    var vp1 = vectorMultiplyProjective( viewProjViewport, p1 );
    var vp2 = vectorMultiplyProjective( viewProjViewport, p2 );
    var vp3 = vectorMultiplyProjective( viewProjViewport, p3 );
    var vp4 = vectorMultiplyProjective( viewProjViewport, p4 );

    // Now do a point in polygon test
    // See http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  Solution 3 (2D)
    var i1 = (point.v[1] - vp1.v[1]) * (vp2.v[0] - vp1.v[0]) - (point.v[0] - vp1.v[0]) * (vp2.v[1] - vp1.v[1]);
    var i2 = (point.v[1] - vp2.v[1]) * (vp3.v[0] - vp2.v[0]) - (point.v[0] - vp2.v[0]) * (vp3.v[1] - vp2.v[1]);
    var i3 = (point.v[1] - vp3.v[1]) * (vp4.v[0] - vp3.v[0]) - (point.v[0] - vp3.v[0]) * (vp4.v[1] - vp3.v[1]);
    var i4 = (point.v[1] - vp4.v[1]) * (vp1.v[0] - vp4.v[0]) - (point.v[0] - vp4.v[0]) * (vp1.v[1] - vp4.v[1]);

    if ( ( i1 == 0 ) || ( i2 == 0 ) || ( i3 == 0 ) || ( i4 == 0 ) )
    {
        return 1;
    }

    if ( i1 > 0 )
    {
        return ( i2 > 0 ) && ( i3 > 0 ) && ( i4 > 0 );
    }

    return ( i2 < 0 ) && ( i3 < 0 ) && ( i4 < 0 );
}


// returns a hashmap with .ctx, .viewProj and .viewProjViewport
function build_view_context( ) {
    var canvas = document.getElementById("canvas");   
    var ctx = canvas.getContext("2d");   
    var altitude = $("#slide_alt").val() / 100.0;
    var azimuth = $("#slide_azi").val() / 100.0;

    var height = $('#canvas').attr('height');
    var width = $('#canvas').attr('width');
    var distance = 15;


    // Build the projection matrix
    // Note that the camera looks down -z in view space and the viewplane is at z = -1
    var aspectRatio = height / width;    
    var proj = buildProjectionMatrix( -0.3, 0.3, -0.3 * aspectRatio, 0.3 * aspectRatio, 1.0, 50.0 );

    // Build the view matrix
    var eye = new vec4;
    var center = new vec4;
    var up = new vec4;
    center.v[0] = distance * Math.sin( azimuth ) * Math.sin( altitude )
    center.v[1] = distance * Math.cos( altitude )
    center.v[2] = distance * Math.cos( azimuth ) * Math.sin( altitude )     
    up.v[1] = 1.0;
    eye.v[3] = center.v[3] = up.v[3] = 0.0;   
    var view = buildViewMatrix( center, eye, up );    

    // Build the viewport transform
    var viewport = buildViewportTransform( width, height );
   
    // viewProjViewport matrix will transform all points from world space to screen space
    var viewProj = multiplyMatrix( proj, view );
    var viewProjViewport = multiplyMatrix( viewport, viewProj );    

    return { 'ctx': ctx,
             'viewProj': viewProj,
             'viewProjViewport': viewProjViewport
           };
}


// Returns a number 0-53 if the x,y point (relative to canvas) is one of the faces.
// Returns -1 if no match.
function whichFaceIsPointIn( x,y )
{
    var point = new vec4;
    point.v[0] = x;
    point.v[1] = y;

    var view_context = build_view_context();

    var quadlist = buildQuadList( view_context['ctx'], view_context['viewProj'], view_context['viewProjViewport'] );
    for( ndx=0; ndx<54; ndx++) {
        var quad = quadlist[ndx];
        if( isPointInQuad( view_context['ctx'], view_context['viewProj'], view_context['viewProjViewport'], quad[0], quad[1], quad[2], quad[3], point ) ) {
            // found it.  break out of loop.
            return ndx;
        }
    }
    return -1;
}


function buildQuadList( ctx, viewProj, viewProjViewport ) {
    // This code generates the 54 quads representing the 54 pixels of the cube    
    var crossAxis = [ [1, 2], [0, 2], [0, 1] ];
    var invertAxis = [ [false, false], [true, false], [true, false], [false, false], [false, false], [true, false] ];
    var gapSize = 0.08;
    var p = new vec4;
    var d = [ 0.0, 0.0, 0.0 ];
    var g = [ 0.0, 0.0, 0.0 ];

    var black = [ 0.0, 0.0, 0.0, 0.0 ];
    var quadlist = [];
    for ( var i = 0; i < 6; ++i )
    {
        var axis = i >> 1;
        p.v[axis] = 3.0;
        if ( i & 1 )
        {
            p.v[axis] *= -1.0;
        }
        d[axis] = 0.0;

        var a0 = crossAxis[ axis ][ 0 ];
        var a1 = crossAxis[ axis ][ 1 ];
        var s0 = 1.0;
        var s1 = 1.0;
        if ( invertAxis[ i ][ 0 ] )
        {
            s0 *= -1.0;
        }
        if ( invertAxis[ i ][ 1 ] )
        {
            s1 *= -1.0
        }
        d[a0] = ( 2.0 - 2.0 * gapSize ) * s0;
        d[a1] = ( 2.0 - 2.0 * gapSize ) * s1;
        g[a0] = gapSize * s0;
        g[a1] = gapSize * s1;
        p.v[a1] = -3.0 * s1 + g[a1];
        for ( var j = 0; j < 3; j++ )
        {
            p.v[a0] = -3.0 * s0 + g[a0]
            for ( var k = 0; k < 3; k++ )
            {           
                var p1 = vectorCopy( p );

                p.v[ a0 ] += d[ a0 ]
                var p2 = vectorCopy( p );

                p.v[ a1 ] += d[ a1 ];
                var p3 = vectorCopy( p );
                
                p.v[ a0 ] -= d[ a0 ];
                var p4 = vectorCopy( p );

                var ndx = i*9 + j*3 + k        
                quadlist[ ndx ] = [p1,p2,p3,p4];
                
                p.v[ a1 ] -= d[ a1 ];
                p.v[ a0 ] += d[ a0 ] + 2.0 * g[ a0 ];
            }                     
            p.v[ a1 ] += d[ a1 ] + 2.0 * g[ a1 ];
        }
    }           
    return quadlist;
}


//-----------------------------------------------------------------------------
// This draws an arrow, projecting it from world space to screenspace, and then rendering it.
// Arguments:
// viewProj: a matrix which concatenates the view + projection matrices
// viewProjViewport: a matrix which concatenates the view, projection, and viewport matrices
// p1-p4: the 4 quad points to render in
// orientation: a number 0-3 indicating the orientation
//-----------------------------------------------------------------------------
function drawArrow( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, orientation, color )
{
    // Backface cull first
    var b1 = vectorMultiplyProjective( viewProj, p1 );
    var b2 = vectorMultiplyProjective( viewProj, p2 );
    var b3 = vectorMultiplyProjective( viewProj, p3 );
    var e1 = vectorSubtract( b2, b1 );
    var e2 = vectorSubtract( b3, b1 );
    var c = vectorCross( e1, e2 );
    if ( c.v[2] <= 0.0 )
    {
        return;
    }

    ctx.fillStyle = "rgba(" + Math.round(255.0*color[2]) + "," + Math.round(255.0*color[1]) + "," + Math.round(255.0*color[0]) + ",1)";
    ctx.globalAlpha = 1.0;

    // Build basis
    var origin;
    var up;
    var right;
    if ( orientation == 0 )
    {
        origin = p1;
        up = vectorSubtract( p4, p1 );
        right = vectorSubtract( p2, p1 );
    }
    else if ( orientation == 1 )
    {
        origin = p2;
        up = vectorSubtract( p1, p2 );
        right = vectorSubtract( p3, p2 );
    }
    else if ( orientation == 2 )
    {
        origin = p3;
        up = vectorSubtract( p2, p3 );
        right = vectorSubtract( p4, p3 );
    }
    else if ( orientation == 3 )
    {
        origin = p4;
        up = vectorSubtract( p3, p4 );
        right = vectorSubtract( p1, p4 );
    }

    // Build arrow points
    var borderAmount = 0.1;
    var baseAmount = 0.3;
    var arrowVertAmount = 0.4;

    var a1 = vectorMultiplyAdd2( origin, up, borderAmount, right, baseAmount );
    var a2 = vectorMultiplyAdd2( origin, up, borderAmount, right, 1.0 - baseAmount );
    var a3 = vectorMultiplyAdd2( origin, up, arrowVertAmount, right, 1.0 - baseAmount );
    var a4 = vectorMultiplyAdd2( origin, up, arrowVertAmount, right, 1.0 - borderAmount );
    var a5 = vectorMultiplyAdd2( origin, up, 1.0 - borderAmount, right, 0.5 );
    var a6 = vectorMultiplyAdd2( origin, up, arrowVertAmount, right, borderAmount );
    var a7 = vectorMultiplyAdd2( origin, up, arrowVertAmount, right, baseAmount );

    // Transform all points into viewport space
    var vp1 = vectorMultiplyProjective( viewProjViewport, a1 );
    var vp2 = vectorMultiplyProjective( viewProjViewport, a2 );
    var vp3 = vectorMultiplyProjective( viewProjViewport, a3 );
    var vp4 = vectorMultiplyProjective( viewProjViewport, a4 );
    var vp5 = vectorMultiplyProjective( viewProjViewport, a5 );
    var vp6 = vectorMultiplyProjective( viewProjViewport, a6 );
    var vp7 = vectorMultiplyProjective( viewProjViewport, a7 );

    // Draw a filled quad
    ctx.beginPath();
    ctx.moveTo(vp1.v[0], vp1.v[1]);
    ctx.lineTo(vp2.v[0], vp2.v[1]);
    ctx.lineTo(vp3.v[0], vp3.v[1]);
    ctx.lineTo(vp4.v[0], vp4.v[1]);
    ctx.lineTo(vp5.v[0], vp5.v[1]);
    ctx.lineTo(vp6.v[0], vp6.v[1]);
    ctx.lineTo(vp7.v[0], vp7.v[1]);
    ctx.closePath();
    ctx.fill();
}

// x = 1,-1 y = 2,-2 z = 3,-3 !rotate = 0
arrowRotation = [
-2,0,2,-2,0,2,-2,0,2,  //1,-1,3,1,-1,3,1,-1,3,
2,0,-2,2,0,-2,2,0,-2,  //1,-1,3,1,-1,3,1,-1,3,

-3,-3,-3,0,0,0,3,3,3,  //2,2,2,-1,-1,-1,0,0,0,
-3,-3,-3,0,0,0,3,3,3,  //2,2,2,-1,-1,-1,0,0,0,

-1,0,1,-1,0,1,-1,0,1,   //1,-1,3,1,-1,3,1,-1,3,
1,0,-1,1,0,-1,1,0,-1,   //1,-1,3,1,-1,3,1,-1,3,
];
// x[],y[],z[] then
// +x,-x,+y,-y,+z,-z
rotToOrient = [[ -1, -1, 1, 3, 3, 1 ],
               [ 3, 1, -1, -1, 0, 0 ], 
               [ 2, 2, 0, 0, -1, -1 ] ];

function drawCube( ctx, viewProj, viewProjViewport, colors )
{
    var quadlist = buildQuadList( ctx, viewProj, viewProjViewport );
    for( ndx=0; ndx<54; ndx++) {
        var quad = quadlist[ndx];

        // draw the arrow slightly darker than the actual color
        var darkcolor = [ colors[ndx][0]*.6, colors[ndx][1]*.6, colors[ndx][2]*.6 ]
        drawQuad( ctx, viewProj, viewProjViewport, quad[0], quad[1], quad[2], quad[3], colors[ndx] );
        if (arrowRotation[ndx] !=0) {
            sign = arrowRotation[ndx] < 0;
            arrowDirection = rotToOrient[Math.abs(arrowRotation[ndx]) - 1][Math.floor(ndx / 9)]
            if (sign) {
              arrowDirection = (2 + arrowDirection) % 4
            }
            //console.log(arrowRotation[ndx], Math.floor(ndx/9), sign, arrowDirection)
            if (arrowDirection >= 0) {
              drawArrow( ctx, viewProj, viewProjViewport, quad[0], quad[1], quad[2], quad[3], arrowDirection, darkcolor );
            }
        }
    }           
}

    // Define cube colors (these should be passed in)
    var faceColors = [ [ 0.0, 1.0, 0.0 ], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0] ];
    var current_cube_colors = new Array( 54 );
    var index = 0;
    for ( var i = 0; i < 6; ++i )
    {
        for ( var j = 0; j < 9; ++j )
        {
            current_cube_colors[index] = faceColors[i];
            index++;            
        }
    }


function render_view( width, height, altitude, azimuth, distance ) 
{ 
    var canvas = document.getElementById("canvas");   
    var ctx = canvas.getContext("2d");   

    // Clear to black
    ctx.save();   
    ctx.fillStyle = "black";   
    ctx.fillRect( 0, 0, width, height );   
    ctx.restore();   
    
    var view_context = build_view_context();
    drawCube( view_context['ctx'], view_context['viewProj'], view_context['viewProjViewport'], current_cube_colors );
}


            </script>   
        </head>
    <body>
       <canvas id="canvas" width="300" height="300"></canvas>   

       <script>
       </script>

       <div>
          Altitude: <input id="slide_alt" type="range" min="1" max="313" value="220" onchange="update_view();"><br/>
          Azimuth: <input id="slide_azi" type="range" min="0" max="628" value="233" onchange="update_view();"><br/>
       </div>
    </body> 
</html>  


