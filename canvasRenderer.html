<html>   
      <head>   
            <script type="application/javascript">
            
//-----------------------------------------------------------------------------             
// Standard 4D vector math utility methods
// When using 4D vectors, positions are represented by [ x, y, z, 1 ]
// and directions are represented by [ x, y, z, 0 ]
//-----------------------------------------------------------------------------             
function vec4() 
{
    this.v = [ 0, 0, 0, 1 ]
}

function vectorSubtract( a, b )
{
    r = new vec4;
    r.v[0] = a.v[0] - b.v[0];
    r.v[1] = a.v[1] - b.v[1];
    r.v[2] = a.v[2] - b.v[2];
    r.v[3] = a.v[3] - b.v[3];  
    return r;          
}

function vectorSet( v, x, y, z, w )
{
    v.v[0] = x;
    v.v[1] = y;
    v.v[2] = z;
    v.v[3] = w;
}

function vectorCopy( v )
{
    r = new vec4;
    r.v[0] = v.v[0];
    r.v[1] = v.v[1];
    r.v[2] = v.v[2];
    r.v[3] = v.v[3];
    return r;
}

function vectorNormalize( v )
{
    mag = v.v[0] * v.v[0] + v.v[1] * v.v[1] + v.v[2] * v.v[2] + v.v[3] * v.v[3];
    if ( mag == 0.0 )
    {
        mag = 1.0
    }
    r = new vec4;
    mag = Math.sqrt( 1.0 / mag );
    r.v[0] = v.v[0] * mag;
    r.v[1] = v.v[1] * mag;
    r.v[2] = v.v[2] * mag;
    r.v[3] = v.v[3] * mag;
    return r;
}

function vectorCross( a, b )
{
    r = new vec4;
    r.v[0] = a.v[1]*b.v[2] - a.v[2]*b.v[1];
    r.v[1] = a.v[2]*b.v[0] - a.v[0]*b.v[2];
    r.v[2] = a.v[0]*b.v[1] - a.v[1]*b.v[0];
    r.v[3] = 0.0
    return r;
}


//-----------------------------------------------------------------------------             
// Note that we're doing column-major matrices. 
// Vectors are pre-multiplied by matrices to transform them, i.e. vtransform = mat * v;
// This is *not* the method OpenGL uses (they post-multiply vectors by matrices)
// If you're not familiar w/ matrices, the upper 3x3 represents a rotation
// and the 3rd column represents the translational component for a 
// orthonormal matrix.
//-----------------------------------------------------------------------------             
function matrix() 
{
    this.m = [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ];
}

function multiplyMatrix( a, b ) 
{
    r = new matrix()
    r.m[0][0] = a.m[0][0] * b.m[0][0] + a.m[0][1] * b.m[1][0] + a.m[0][2] * b.m[2][0] + a.m[0][3] * b.m[3][0];
    r.m[0][1] = a.m[0][0] * b.m[0][1] + a.m[0][1] * b.m[1][1] + a.m[0][2] * b.m[2][1] + a.m[0][3] * b.m[3][1];
    r.m[0][2] = a.m[0][0] * b.m[0][2] + a.m[0][1] * b.m[1][2] + a.m[0][2] * b.m[2][2] + a.m[0][3] * b.m[3][2];
    r.m[0][3] = a.m[0][0] * b.m[0][3] + a.m[0][1] * b.m[1][3] + a.m[0][2] * b.m[2][3] + a.m[0][3] * b.m[3][3];

    r.m[1][0] = a.m[1][0] * b.m[0][0] + a.m[1][1] * b.m[1][0] + a.m[1][2] * b.m[2][0] + a.m[1][3] * b.m[3][0];
    r.m[1][1] = a.m[1][0] * b.m[0][1] + a.m[1][1] * b.m[1][1] + a.m[1][2] * b.m[2][1] + a.m[1][3] * b.m[3][1];
    r.m[1][2] = a.m[1][0] * b.m[0][2] + a.m[1][1] * b.m[1][2] + a.m[1][2] * b.m[2][2] + a.m[1][3] * b.m[3][2];
    r.m[1][3] = a.m[1][0] * b.m[0][3] + a.m[1][1] * b.m[1][3] + a.m[1][2] * b.m[2][3] + a.m[1][3] * b.m[3][3];

    r.m[2][0] = a.m[2][0] * b.m[0][0] + a.m[2][1] * b.m[1][0] + a.m[2][2] * b.m[2][0] + a.m[2][3] * b.m[3][0];
    r.m[2][1] = a.m[2][0] * b.m[0][1] + a.m[2][1] * b.m[1][1] + a.m[2][2] * b.m[2][1] + a.m[2][3] * b.m[3][1];
    r.m[2][2] = a.m[2][0] * b.m[0][2] + a.m[2][1] * b.m[1][2] + a.m[2][2] * b.m[2][2] + a.m[2][3] * b.m[3][2];
    r.m[2][3] = a.m[2][0] * b.m[0][3] + a.m[2][1] * b.m[1][3] + a.m[2][2] * b.m[2][3] + a.m[2][3] * b.m[3][3];

    r.m[3][0] = a.m[3][0] * b.m[0][0] + a.m[3][1] * b.m[1][0] + a.m[3][2] * b.m[2][0] + a.m[3][3] * b.m[3][0];
    r.m[3][1] = a.m[3][0] * b.m[0][1] + a.m[3][1] * b.m[1][1] + a.m[3][2] * b.m[2][1] + a.m[3][3] * b.m[3][1];
    r.m[3][2] = a.m[3][0] * b.m[0][2] + a.m[3][1] * b.m[1][2] + a.m[3][2] * b.m[2][2] + a.m[3][3] * b.m[3][2];
    r.m[3][3] = a.m[3][0] * b.m[0][3] + a.m[3][1] * b.m[1][3] + a.m[3][2] * b.m[2][3] + a.m[3][3] * b.m[3][3];
    return r;
}
                  
function vectorMultiply( m, v )
{
    res = new vec4( );
    res.v[0] = m.m[0][0] * v.v[0] + m.m[0][1] * v.v[1] + m.m[0][2] * v.v[2] + m.m[0][3] * v.v[3];
    res.v[1] = m.m[1][0] * v.v[0] + m.m[1][1] * v.v[1] + m.m[1][2] * v.v[2] + m.m[1][3] * v.v[3];
    res.v[2] = m.m[2][0] * v.v[0] + m.m[2][1] * v.v[1] + m.m[2][2] * v.v[2] + m.m[2][3] * v.v[3];
    res.v[3] = m.m[3][0] * v.v[0] + m.m[3][1] * v.v[1] + m.m[3][2] * v.v[2] + m.m[3][3] * v.v[3];
    return res;
}

function vectorMultiplyProjective( m, v )
{
    // When doing a projective transformation, you end up with a w that is not 1
    // To turn it into a normal position vector, you must divide by w
    // which actually has the effect of doing the projection onto a plane where w = 1
    r = new vec4( );
    r.v[0] = m.m[0][0] * v.v[0] + m.m[0][1] * v.v[1] + m.m[0][2] * v.v[2] + m.m[0][3] * v.v[3];
    r.v[1] = m.m[1][0] * v.v[0] + m.m[1][1] * v.v[1] + m.m[1][2] * v.v[2] + m.m[1][3] * v.v[3];
    r.v[2] = m.m[2][0] * v.v[0] + m.m[2][1] * v.v[1] + m.m[2][2] * v.v[2] + m.m[2][3] * v.v[3];
    r.v[3] = m.m[3][0] * v.v[0] + m.m[3][1] * v.v[1] + m.m[3][2] * v.v[2] + m.m[3][3] * v.v[3];     
    if ( r.v[3] != 0.0 ) 
    {
        oow = 1.0 / r.v[3];
        r.v[0] = r.v[0] * oow
        r.v[1] = r.v[1] * oow
        r.v[2] = r.v[2] * oow
    }
    r.v[3] = 1.0
    return r;
}


function matrixInvert( src )
{
    // NOTE: This only works for orthonormal matrices
    r = new matrix()

    // Transpose the upper 3x3.
    r.m[0][0] = src.m[0][0];  r.m[0][1] = src.m[1][0]; r.m[0][2] = src.m[2][0];
    r.m[1][0] = src.m[0][1];  r.m[1][1] = src.m[1][1]; r.m[1][2] = src.m[2][1];
    r.m[2][0] = src.m[0][2];  r.m[2][1] = src.m[1][2]; r.m[2][2] = src.m[2][2];

    // Transform the translation.
    vTrans = new vec4();
    vectorSet( vTrans, -src.m[0][3], -src.m[1][3], -src.m[2][3], 1.0 );
    vNewTrans = vectorMultiply( r, vTrans );
    r.m[0][3] = vNewTrans.v[0];
    r.m[1][3] = vNewTrans.v[1];
    r.m[2][3] = vNewTrans.v[2]; 
    return r;
}


//-----------------------------------------------------------------------------             
// Some basics of doing a 3d -> 2d transformation: There are 3 important matrices
// 1) The 'camera' or 'view' matrix: This represents the *inverse* of position
// and orientation of the camera in world space, and is used to transform
// world-space points into the coordinate frame of the camera.
// The camera "looks" down its -z axis, its x axis is pointing right in the image plane
// and its y axis is pointing up in the image plane. All geometry will be projected
// onto the z = -1 plane.
// 2) The 'projection' matrix: This transforms geometry in camera space to
// lie on the z =-1 plane. In projection space, everything that lies
// between -1 and 1 in x, y and z will show up on screen.
// 3) The 'viewport' matrix: This transforms geometry in projection space to
// pixel space on screen by translating and scaling x and y. Z is left unchanged.
//-----------------------------------------------------------------------------             
function buildProjectionMatrix( left, right, bottom, top, near, far )
{
    r = new matrix();
    r.m[0][0] = ( 2 * near ) / ( right - left );
    r.m[1][1] = ( 2 * near ) / ( top - bottom );
    r.m[2][0] = ( right + left ) / ( right - left );    
    r.m[2][1] = ( top + bottom ) / ( top - bottom );     
    r.m[2][2] = ( far + near ) / ( far - near );
    r.m[2][3] = -1;
    r.m[3][2] = 2 * far * near / ( far - near );
    return r;
}

//-----------------------------------------------------------------------------             
// The way to think about how to build a view matrix: Start with trying to
// make a transform that transforms from camera space to world space.
// Such a transform should have the property that post-multiplying the
// matrix by the column vector [ 0 0 0 1 ] should result in the camera origin
// in world space. Post-multiplying the matrix by [ 0 0 1 0 ] should result
// in the 'z' axis of the camera in world space, etc. The first property means that
// the 3rd column (the translational component of the matrix) needs to be
// the camera location in 3D space (equals 'eye'). The second means that each
// column of the matrix represents the x, y, and z axes of the camera.
// Inverting this matrix results in the view matrix that transforms world-space
// points into camera-space points.
//-----------------------------------------------------------------------------             
function buildViewMatrix( eye, center, up )
{
    f = vectorSubtract( eye, center );

    f = vectorNormalize( f );
    s = vectorCross( up, f );
    s = vectorNormalize( s );
    u = vectorCross( f, s );
    u = vectorNormalize( u );

    t = new matrix();
    t.m[0][3] = eye.v[0];
    t.m[1][3] = eye.v[1];
    t.m[2][3] = eye.v[2];
  
    rot = new matrix();
    rot.m[0][0] = s.v[0]; 
    rot.m[0][1] = u.v[0];
    rot.m[0][2] = f.v[0];
    
    rot.m[1][0] = s.v[1]; 
    rot.m[1][1] = u.v[1];
    rot.m[1][2] = f.v[1];
   
    rot.m[2][0] = s.v[2]; 
    rot.m[2][1] = u.v[2];
    rot.m[2][2] = f.v[2];

    v = multiplyMatrix( t, rot );        
    vInv = matrixInvert( v );    
    return vInv;
}

function buildViewportTransform( width, height )
{
    r = new matrix();
    r.m[0][0] = 0.5 * width; 
    r.m[0][3] = 0.5 * height; 
    r.m[1][1] = -0.5 * height; 
    r.m[1][3] = 0.5 * height;
    return r; 
}
                    

//-----------------------------------------------------------------------------
// This draws a quad, projecting it from world space to screenspace, and then rendering it.
// Arguments:
// viewProj: a matrix which concatenates the view + projection matrices
// viewProjViewport: a matrix which concatenates the view, projection, and viewport matrices
// 
//-----------------------------------------------------------------------------             
function drawQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, color ) 
{
    // Backface cull first
    b1 = vectorMultiplyProjective( viewProj, p1 );
    b2 = vectorMultiplyProjective( viewProj, p2 );
    b3 = vectorMultiplyProjective( viewProj, p3 );
    e1 = vectorSubtract( b2, b1 );
    e2 = vectorSubtract( b3, b1 );
    c = vectorCross( e1, e2 );
    if ( c.v[2] <= 0.0 )
    {
        return;
    }
            
    ctx.fillStyle = "rgba(" + 255*color[2] + "," + 255*color[1] + "," + 255*color[0] + ",1)";
    ctx.globalAlpha = 1.0; 
     
    // Transform all points into viewport space
    vp1 = vectorMultiplyProjective( viewProjViewport, p1 );  
    vp2 = vectorMultiplyProjective( viewProjViewport, p2 );  
    vp3 = vectorMultiplyProjective( viewProjViewport, p3 );  
    vp4 = vectorMultiplyProjective( viewProjViewport, p4 );
        
    // Draw a filled quad  
    ctx.beginPath();   
    ctx.moveTo(vp1.v[0], vp1.v[1]);   
    ctx.lineTo(vp2.v[0], vp2.v[1]);   
    ctx.lineTo(vp3.v[0], vp3.v[1]);   
    ctx.lineTo(vp4.v[0], vp4.v[1]);   
    ctx.closePath();   
    ctx.fill();
}   

function drawCube( ctx, viewProj, viewProjViewport, colors )
{
    // This code generates the 54 quads representing the 54 pixels of the cube    
    crossAxis = [ [1, 2], [0, 2], [0, 1] ];
    invertAxis = [ [false, false], [true, false], [true, false], [false, false], [false, false], [true, false] ];
    gapSize = 0.08;
    p = new vec4;
    d = [ 0.0, 0.0, 0.0 ];
    g = [ 0.0, 0.0, 0.0 ];

    for ( i = 0; i < 6; ++i )
    {
        axis = i >> 1;
        p.v[axis] = 3.0;
        if ( i & 1 )
        {
            p.v[axis] *= -1.0;
        }
        d[axis] = 0.0;

        a0 = crossAxis[ axis ][ 0 ];
        a1 = crossAxis[ axis ][ 1 ];
        s0 = 1.0;
        s1 = 1.0;
        if ( invertAxis[ i ][ 0 ] )
        {
            s0 *= -1.0;
        }
        if ( invertAxis[ i ][ 1 ] )
        {
            s1 *= -1.0
        }
        d[a0] = ( 2.0 - 2.0 * gapSize ) * s0;
        d[a1] = ( 2.0 - 2.0 * gapSize ) * s1;
        g[a0] = gapSize * s0;
        g[a1] = gapSize * s1;
        p.v[a1] = -3.0 * s1 + g[a1];
        for ( j = 0; j < 3; j++ )
        {
            p.v[a0] = -3.0 * s0 + g[a0]
            for ( k = 0; k < 3; k++ )
            {           
                p1 = vectorCopy( p );

                p.v[ a0 ] += d[ a0 ]
                p2 = vectorCopy( p );

                p.v[ a1 ] += d[ a1 ];
                p3 = vectorCopy( p );
                
                p.v[ a0 ] -= d[ a0 ];
                p4 = vectorCopy( p );

                ndx = i*9 + j*3 + k        
                drawQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, colors[ndx] );
                
                p.v[ a1 ] -= d[ a1 ];
                p.v[ a0 ] += d[ a0 ] + 2.0 * g[ a0 ];
            }                     
            p.v[ a1 ] += d[ a1 ] + 2.0 * g[ a1 ];
        }
    }           
}

function draw( width, height, altitude, azimuth, distance ) 
{ 
    canvas = document.getElementById("canvas");   
    ctx = canvas.getContext("2d");   

    // Clear to black
    ctx.save();   
    ctx.fillStyle = "black";   
    ctx.fillRect( 0, 0, width, height );   
    ctx.restore();   
    
    // Define cube colors (these should be passed in)
    faceColors = [ [ 0.0, 1.0, 0.0 ], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0] ];
    colors = new Array( 54 );
    index = 0;
    for ( i = 0; i < 6; ++i )
    {
        for ( j = 0; j < 9; ++j )
        {
            colors[index] = faceColors[i];
            index++;            
        }
    }
    
    // Build the projection matrix
    // Note that the camera looks down -z in view space and the viewplane is at z = -1
    aspectRatio = height / width;    
    proj = buildProjectionMatrix( -0.3, 0.3, -0.3 * aspectRatio, 0.3 * aspectRatio, 1.0, 50.0 );

    // Build the view matrix
    eye = new vec4;
    center = new vec4;
    up = new vec4;
    center.v[0] = distance * Math.sin( azimuth ) * Math.sin( altitude )
    center.v[1] = distance * Math.cos( altitude )
    center.v[2] = distance * Math.cos( azimuth ) * Math.sin( altitude )     
    up.v[1] = 1.0;
    eye.v[3] = center.v[3] = up.v[3] = 0.0;   
    view = buildViewMatrix( center, eye, up );    

    // Build the viewport transform
    viewport = buildViewportTransform( width, height );
   
    // viewProjViewport matrix will transform all points from world space to screen space
    viewProj = multiplyMatrix( proj, view );
    viewProjViewport = multiplyMatrix( viewport, viewProj );    
    
    drawCube( ctx, viewProj, viewProjViewport, colors );
}
            </script>   
        </head>
    <body onload="draw(300, 300, -2.2, 2.335, 15 )">   
       <canvas id="canvas" width="300" height="300"></canvas>   
    </body> 
</html>  


