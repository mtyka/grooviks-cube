<html>   
      <head>   
            <script type="text/javascript" src="vectormath.js"></script>
            <script type="text/javascript" src="render3d.js"></script>
            <script type="text/javascript">
function drawCube( ctx, viewProj, viewProjViewport, colors )
{
    // This code generates the 54 quads representing the 54 pixels of the cube    
    crossAxis = [ [1, 2], [0, 2], [0, 1] ];
    invertAxis = [ [false, false], [true, false], [true, false], [false, false], [false, false], [true, false] ];
    gapSize = 0.08;
    p = new vec4;
    d = [ 0.0, 0.0, 0.0 ];
    g = [ 0.0, 0.0, 0.0 ];

    for ( i = 0; i < 6; ++i )
    {
        axis = i >> 1;
        p.v[axis] = 3.0;
        if ( i & 1 )
        {
            p.v[axis] *= -1.0;
        }
        d[axis] = 0.0;

        a0 = crossAxis[ axis ][ 0 ];
        a1 = crossAxis[ axis ][ 1 ];
        s0 = 1.0;
        s1 = 1.0;
        if ( invertAxis[ i ][ 0 ] )
        {
            s0 *= -1.0;
        }
        if ( invertAxis[ i ][ 1 ] )
        {
            s1 *= -1.0
        }
        d[a0] = ( 2.0 - 2.0 * gapSize ) * s0;
        d[a1] = ( 2.0 - 2.0 * gapSize ) * s1;
        g[a0] = gapSize * s0;
        g[a1] = gapSize * s1;
        p.v[a1] = -3.0 * s1 + g[a1];
        for ( j = 0; j < 3; j++ )
        {
            p.v[a0] = -3.0 * s0 + g[a0]
            for ( k = 0; k < 3; k++ )
            {           
                p1 = vectorCopy( p );

                p.v[ a0 ] += d[ a0 ]
                p2 = vectorCopy( p );

                p.v[ a1 ] += d[ a1 ];
                p3 = vectorCopy( p );
                
                p.v[ a0 ] -= d[ a0 ];
                p4 = vectorCopy( p );

                ndx = i*9 + j*3 + k        
                drawQuad( ctx, viewProj, viewProjViewport, p1, p2, p3, p4, colors[ndx] );
                
                p.v[ a1 ] -= d[ a1 ];
                p.v[ a0 ] += d[ a0 ] + 2.0 * g[ a0 ];
            }                     
            p.v[ a1 ] += d[ a1 ] + 2.0 * g[ a1 ];
        }
    }           
}

function draw( width, height, altitude, azimuth, distance ) 
{ 
    canvas = document.getElementById("canvas");   
    ctx = canvas.getContext("2d");   

    // Clear to black
    ctx.save();   
    ctx.fillStyle = "black";   
    ctx.fillRect( 0, 0, width, height );   
    ctx.restore();   
    
    // Define cube colors (these should be passed in)
    faceColors = [ [ 0.0, 1.0, 0.0 ], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0] ];
    colors = new Array( 54 );
    index = 0;
    for ( i = 0; i < 6; ++i )
    {
        for ( j = 0; j < 9; ++j )
        {
            colors[index] = faceColors[i];
            index++;            
        }
    }
    
    // Build the projection matrix
    // Note that the camera looks down -z in view space and the viewplane is at z = -1
    aspectRatio = height / width;    
    proj = buildProjectionMatrix( -0.3, 0.3, -0.3 * aspectRatio, 0.3 * aspectRatio, 1.0, 50.0 );

    // Build the view matrix
    eye = new vec4;
    center = new vec4;
    up = new vec4;
    center.v[0] = distance * Math.sin( azimuth ) * Math.sin( altitude )
    center.v[1] = distance * Math.cos( altitude )
    center.v[2] = distance * Math.cos( azimuth ) * Math.sin( altitude )     
    up.v[1] = 1.0;
    eye.v[3] = center.v[3] = up.v[3] = 0.0;   
    view = buildViewMatrix( center, eye, up );    

    // Build the viewport transform
    viewport = buildViewportTransform( width, height );
   
    // viewProjViewport matrix will transform all points from world space to screen space
    viewProj = multiplyMatrix( proj, view );
    viewProjViewport = multiplyMatrix( viewport, viewProj );    
    
    drawCube( ctx, viewProj, viewProjViewport, colors );
}
            </script>   
        </head>
    <body onload="draw(300, 300, -2.2, 2.335, 15 )">   
       <canvas id="canvas" width="300" height="300"></canvas>   
    </body> 
</html>  


